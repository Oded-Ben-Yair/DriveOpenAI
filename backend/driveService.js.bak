// backend/driveService.js
import { google } from 'googleapis';
import { oauth2Client, refreshAccessToken } from './auth.js';
import mammoth from 'mammoth';
import logger from './logger.js';
import { retryWithBackoff } from './utils.js';
import { extractTextFromPDF } from './patches/pdf-parse-fix.js'; 

// In-memory cache
const fileContentCache = new Map();
const FILE_CACHE_TTL_MS = 30 * 60 * 1000; // 30 minutes

// Initialize drive API
const drive = google.drive({ version: 'v3', auth: oauth2Client });

// List files with filtering options
export async function listFiles({ 
  limit = 10, 
  offset = 0,
  modifiedAfter = null,
  modifiedBefore = null,
  mimeType = null
} = {}) {
  try {
    // Build query for filtering
    let query = 'trashed=false';
    
    if (modifiedAfter) {
      query += ` and modifiedTime > "${modifiedAfter}"`;
    }
    
    if (modifiedBefore) {
      query += ` and modifiedTime < "${modifiedBefore}"`;
    }
    
    if (mimeType) {
      query += ` and mimeType = "${mimeType}"`;
    }
    
    const response = await retryWithBackoff(() => drive.files.list({
      pageSize: Number(limit),
      pageToken: offset || undefined,
      q: query,
      fields: 'nextPageToken, files(id, name, mimeType, owners, modifiedTime, size, webViewLink, md5Checksum)'
    }));
    
    return response.data;
  } catch (error) {
    // If token is expired, try to refresh
    if (error.code === 401) {
      const refreshed = await refreshAccessToken();
      if (refreshed) {
        // Retry the request with new token
        return listFiles({ limit, offset, modifiedAfter, modifiedBefore, mimeType });
      }
    }
    
    logger.error('Error listing files:', error);
    throw error;
  }
}

// Get file by ID with more details
export async function getFileById(fileId) {
  try {
    const response = await retryWithBackoff(() => drive.files.get({
      fileId,
      fields: 'id, name, mimeType, owners, modifiedTime, size, webViewLink, description, md5Checksum'
    }));
    
    return response.data;
  } catch (error) {
    logger.error(`Error getting file ${fileId}:`, error);
    throw error;
  }
}

// Delete file by ID
export async function deleteFile(fileId) {
  try {
    await retryWithBackoff(() => drive.files.delete({ fileId }));
    // Also remove from cache if present
    fileContentCache.delete(fileId);
  } catch (error) {
    logger.error(`Error deleting file ${fileId}:`, error);
    throw error;
  }
}

// Update file metadata
export async function updateFile(fileId, metadata) {
  try {
    const response = await retryWithBackoff(() => drive.files.update({
      fileId,
      requestBody: metadata,
      fields: 'id, name, mimeType, owners, modifiedTime, size, webViewLink, description'
    }));
    
    return response.data;
  } catch (error) {
    logger.error(`Error updating file ${fileId}:`, error);
    throw error;
  }
}

/**
 * Extract text from a DOCX Buffer
 * @param {Buffer} buffer - DOCX file buffer
 * @returns {Promise<string>} - Extracted text
 */
export async function extractTextFromDocx(buffer) {
  try {
    const { value } = await mammoth.extractRawText({ buffer });
    return value;
  } catch (error) {
    logger.error('Error extracting text from DOCX:', error);
    return ''; // Return empty string on error
  }
}

/**
 * Get file content by ID and extract text
 * @param {string} fileId - Google Drive file ID
 * @param {string} [mimeType] - Optional mime type (if known)
 * @returns {Promise<string>} - Extracted text content
 */
export async function getFileContent(fileId, mimeType) {
  // Check cache first
  if (fileContentCache.has(fileId)) {
    const cacheEntry = fileContentCache.get(fileId);
    // If cache is still valid
    if (Date.now() - cacheEntry.timestamp < FILE_CACHE_TTL_MS) {
      logger.debug(`Cache hit for file ${fileId}`);
      return cacheEntry.content;
    }
    // Cache expired, remove entry
    fileContentCache.delete(fileId);
  }
  
  try {
    // If mime type not provided, get file details first
    if (!mimeType) {
      const fileDetails = await getFileById(fileId);
      mimeType = fileDetails.mimeType;
    }
    
    let content = '';
    
    // For Google Docs, Sheets, Slides, etc.
    if (mimeType.startsWith('application/vnd.google-apps')) {
      let exportMime;
      
      // Choose appropriate export format based on Google Workspace file type
      if (mimeType === 'application/vnd.google-apps.document') {
        exportMime = 'text/plain';
      } else if (mimeType === 'application/vnd.google-apps.spreadsheet') {
        exportMime = 'text/csv';
      } else if (mimeType === 'application/vnd.google-apps.presentation') {
        exportMime = 'text/plain';
      } else {
        // Default to plain text for other Google types
        exportMime = 'text/plain';
      }
      
      // Export Google Workspace files
      const response = await retryWithBackoff(() => 
        drive.files.export({ fileId, mimeType: exportMime }, { responseType: 'arraybuffer' })
      );
      
      content = Buffer.from(response.data).toString('utf-8');
    } else {
      // For regular files (PDFs, DOCXs, TXTs, etc.)
      const response = await retryWithBackoff(() => 
        drive.files.get({ fileId, alt: 'media' }, { responseType: 'arraybuffer' })
      );
      
      const fileBuffer = Buffer.from(response.data);
      
      // Process based on mime type
      if (mimeType === 'application/pdf') {
        content = await extractTextFromPDF(fileBuffer);
      } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
        content = await extractTextFromDocx(fileBuffer);
      } else if (mimeType.startsWith('text/') || mimeType === 'application/json') {
        // Plain text, JSON, etc.
        content = fileBuffer.toString('utf-8');
      } else {
        // Unsupported file type
        logger.warn(`Unsupported file type: ${mimeType} for file ${fileId}`);
        content = `[Unsupported file type: ${mimeType}]`;
      }
    }
    
    // Cache the content
    fileContentCache.set(fileId, {
      content,
      timestamp: Date.now()
    });
    
    return content;
  } catch (error) {
    logger.error(`Error getting content for file ${fileId}:`, error);
    throw error;
  }
}

/**
 * List all files and index their content
 * @param {object} options - Filter options
 * @param {number} [options.maxFiles=100] - Maximum number of files to index
 * @returns {Promise<Array>} - List of processed files
 */
export async function listAndIndexFiles(options = { maxFiles: 100 }) {
  const indexableFiles = [];
  let pageToken = null;
  let totalFiles = 0;
  
  try {
    do {
      const response = await listFiles({ 
        limit: 50,
        offset: pageToken
      });
      
      // Filter files that we can extract text from
      const files = response.files.filter(file => {
        // Include text-based files and known processable types
        return file.mimeType.startsWith('text/') || 
               file.mimeType === 'application/pdf' || 
               file.mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
               file.mimeType.startsWith('application/vnd.google-apps');
      });
      
      indexableFiles.push(...files);
      pageToken = response.nextPageToken;
      totalFiles += files.length;
      
      // Stop if we've reached the max files limit
      if (totalFiles >= options.maxFiles) {
        break;
      }
    } while (pageToken);
    
    logger.info(`Found ${indexableFiles.length} indexable files`);
    return indexableFiles;
  } catch (error) {
    logger.error('Error listing and indexing files:', error);
    throw error;
  }
}